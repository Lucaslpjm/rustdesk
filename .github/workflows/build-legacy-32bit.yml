name: Build Saurus Legacy (32-bit Final v54 Asset Packer)

on:
  workflow_dispatch:

jobs:
  build-legacy:
    runs-on: windows-2019
    
    env:
      RUSTDESK_API_SERVER: ""
      VCPKG_ROOT: "C:\\vcpkg"
      VCPKG_DEFAULT_TRIPLET: x86-windows-static

    steps:
    - name: Checkout Legacy Code (1.1.9)
      uses: actions/checkout@v4
      with:
        repository: rustdesk/rustdesk
        ref: 1.1.9
        submodules: recursive

    - name: Setup Rust (1.65.0)
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: 1.65.0
        targets: i686-pc-windows-msvc

    # --- FERRAMENTAS ---
    - name: Install Build Tools
      run: |
        choco install llvm --version 12.0.0 --allow-downgrade -y
        choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System' -y
      shell: powershell

    # --- LIBSODIUM ---
    - name: Setup Libsodium
      shell: powershell
      run: |
        $Url = "https://download.libsodium.org/libsodium/releases/libsodium-1.0.18-msvc.zip"
        $Zip = "libsodium.zip"
        $maxRetries = 5; $retryCount = 0; $success = $false
        while (-not $success -and $retryCount -lt $maxRetries) {
            try {
                & curl.exe -L -o $Zip $Url --retry 5 --retry-connrefused --connect-timeout 60
                if ((Get-Item $Zip).Length -gt 1000) { $success = $true }
            } catch { Start-Sleep 5; $retryCount++ }
        }
        if (-not $success) { throw "Download Libsodium falhou" }
        Expand-Archive -Path $Zip -DestinationPath "libsodium_install" -Force
        New-Item -ItemType Directory -Force -Path "C:\libs_x86\lib"
        New-Item -ItemType Directory -Force -Path "C:\libs_x86\include"
        $Lib = "libsodium_install\libsodium\Win32\Release\v142\static\libsodium.lib"
        Copy-Item $Lib "C:\libs_x86\lib\libsodium.lib" -Force
        Copy-Item $Lib "C:\libs_x86\lib\sodium.lib" -Force
        Copy-Item "libsodium_install\libsodium\include\*" "C:\libs_x86\include" -Recurse -Force

    - name: Inject Server Configuration
      shell: powershell
      run: |
        $ConfigFile = "libs/hbb_common/src/config.rs"
        $SeuIP = "20.195.216.23:443"
        $SuaChave = "OJ7QiUrqNu0wM13vDSp4nmAlDu6hy3n8hTI5Wksl2Tc="
        if (Test-Path $ConfigFile) {
           $c = Get-Content $ConfigFile -Raw
           $c = $c -replace '(?s)pub const RENDEZVOUS_SERVERS:.*?;', "pub const RENDEZVOUS_SERVERS: &'static [&'static str] = &[`"$SeuIP`"];"
           $c = $c -replace '(?s)pub const RS_PUB_KEY:.*?;', "pub const RS_PUB_KEY: &'static str = `"$SuaChave`";"
           Set-Content -Path $ConfigFile -Value $c -Encoding UTF8
        }

    - name: Fix Legacy Code Logic
      shell: powershell
      run: |
        $ConfigFile = "libs\hbb_common\src\config.rs"
        $c = Get-Content $ConfigFile -Raw
        $c = $c -replace "let _ = CONFIG.read\(\).unwrap\(\);", "let _lock = CONFIG.read().unwrap();"
        Set-Content -Path $ConfigFile -Value $c -Encoding UTF8

    # --- GERADOR DE UI (ASSET PACKER v54) ---
    - name: Inline Assets and AutoInstall
      shell: python
      run: |
        import os
        import shutil
        import re

        # Define diretórios
        SRC_UI = "src/ui"
        HTML_SOURCE = "html" # Pasta original onde o repo baixa os arquivos
        
        # Cria src/ui se não existir
        if not os.path.exists(SRC_UI):
            os.makedirs(SRC_UI)

        # 1. Copia TUDO de html/ para src/ui/
        print("Copying source files from html/ to src/ui/...")
        if os.path.exists(HTML_SOURCE):
            for item in os.listdir(HTML_SOURCE):
                s = os.path.join(HTML_SOURCE, item)
                d = os.path.join(SRC_UI, item)
                if os.path.isfile(s):
                    shutil.copy2(s, d)
        
        # 2. Função para ler arquivos
        def read_file(fname):
            # Procura primeiro em SRC_UI
            fpath = os.path.join(SRC_UI, fname)
            if os.path.exists(fpath):
                with open(fpath, "rb") as f:
                    return f.read().decode("utf-8", errors="ignore").replace("\r", "")
            return ""

        # 3. Lógica de "Inlining" (Substituir import pelo conteúdo)
        def process_content(content):
            # Loop para resolver imports aninhados (css dentro de css)
            for _ in range(5):
                changed = False
                
                # Substituir CSS (@import url(style.css);)
                def sub_css(match):
                    fname = match.group(1)
                    if fname.startswith("http") or fname.startswith("//") or fname.startswith("sciter"): return match.group(0)
                    print(f"  Inlining CSS: {fname}")
                    c = read_file(fname)
                    if c: 
                        nonlocal changed
                        changed = True
                        return f"/* {fname} */\n{c}"
                    return ""
                
                # Substituir TIScript (include "script.tis";)
                def sub_tis(match):
                    fname = match.group(1)
                    if fname.startswith("sciter"): return match.group(0) # Não mexe no reactor!
                    print(f"  Inlining TIS: {fname}")
                    c = read_file(fname)
                    if c:
                        nonlocal changed
                        changed = True
                        return f"// {fname}\n{c}"
                    return ""

                new_content = re.sub(r'@import\s+url\((.*?)\);', sub_css, content)
                new_content = re.sub(r'include\s+"(.*?)";', sub_tis, new_content)
                
                if new_content != content:
                    content = new_content
                else:
                    break
            return content

        # 4. Processar index.html
        index_file = os.path.join(SRC_UI, "index.html")
        if os.path.exists(index_file):
            print("Processing index.html bundle...")
            raw_html = read_file("index.html")
            
            # Resolve os imports
            bundled_html = process_content(raw_html)
            
            # Injeta CSS Global para garantir fundo branco
            if "</head>" in bundled_html:
                bundled_html = bundled_html.replace("</head>", "<style>html, body { background-color: #FFFFFF !important; color: #000; }</style></head>")
            
            # Injeta Auto-Install (Delay 10s para garantir visualização)
            AUTO_INSTALL = """
            <script type="text/tiscript">
              function self.ready() {
                view.state = View.WINDOW_SHOWN;
                stdout.println("SAURUS: UI Loaded. Timer started.");
                self.timer(10000, function() {
                   try { view.install_me(true); } catch(e) {}
                   return false; 
                });
              }
            </script>
            """
            if "</body>" in bundled_html:
                bundled_html = bundled_html.replace("</body>", f"{AUTO_INSTALL}</body>")
            else:
                bundled_html += AUTO_INSTALL
            
            # Salva o index.html "Gordo"
            with open(index_file, "w", encoding="utf-8", newline="\n") as f:
                f.write(bundled_html)
            print("index.html bundled successfully.")

        # 5. Processar outros HTMLs (Chatbox, etc) para não quebrarem
        other_htmls = ["chatbox.html", "cm.html", "install.html", "remote.html"]
        for html_name in other_htmls:
            p = os.path.join(SRC_UI, html_name)
            if os.path.exists(p):
                c = read_file(html_name)
                c = process_content(c) # Inline CSS
                # Adiciona fundo branco
                if "</head>" in c:
                    c = c.replace("</head>", "<style>html { background: #FFF; }</style></head>")
                with open(p, "w", encoding="utf-8", newline="\n") as f:
                    f.write(c)

        # 6. Gerar inline.rs (Mapeamento Rust)
        # Usamos include_bytes! para ler os arquivos que acabamos de modificar/salvar em src/ui
        rust_code = []
        
        # Arquivos obrigatórios mapeados para funções específicas
        mandatory = {
            "get_index": "index.html",
            "get_chatbox": "chatbox.html",
            "get_cm": "cm.html",
            "get_install": "install.html",
            "get_remote": "remote.html",
            "get_css_common": "common.css",
            "get_css_index": "index.css",
            "get_tis_common": "common.tis"
        }
        
        processed_files = set()
        
        for func, fname in mandatory.items():
            # Mesmo que o arquivo esteja vazio ou já embutido, a função precisa existir e retornar algo válido
            rust_code.append(f'pub fn {func}() -> String {{ String::from_utf8_lossy(include_bytes!("{fname}")).to_string() }}')
            processed_files.add(fname)

        # Mapeia qualquer outro arquivo (ex: imagens, outros tis) para funções genéricas
        # Isso evita que o Sciter falhe se tentar carregar algo dinamicamente
        for fname in os.listdir(SRC_UI):
            if fname not in processed_files and os.path.isfile(os.path.join(SRC_UI, fname)) and fname != "inline.rs":
                safe_name = "get_" + fname.replace(".", "_").replace("-", "_")
                rust_code.append(f'pub fn {safe_name}() -> String {{ String::from_utf8_lossy(include_bytes!("{fname}")).to_string() }}')

        with open(os.path.join(SRC_UI, "inline.rs"), "w", encoding="utf-8", newline="\n") as f:
            f.write("\n".join(rust_code))

        print("inline.rs generated.")

    - name: Ensure Resources Exist
      shell: powershell
      run: |
        $icon = Get-ChildItem -Path . -Recurse -Filter "icon.ico" | Select-Object -First 1
        if ($icon) { Copy-Item $icon.FullName ".\icon.ico" -Force } 
        else { & curl.exe -L -o icon.ico "https://raw.githubusercontent.com/rustdesk/rustdesk/master/res/icon.ico" --retry 3 }
        $manifest = Get-ChildItem -Path . -Recurse -Filter "manifest.xml" | Select-Object -First 1
        if ($manifest) { Copy-Item $manifest.FullName ".\manifest.xml" -Force } 
        else { & curl.exe -L -o manifest.xml "https://raw.githubusercontent.com/rustdesk/rustdesk/master/res/manifest.xml" --retry 3 }

    # --- ARQUIVOS AUXILIARES ---
    - name: Create Helper Files (Src)
      shell: powershell
      run: |
        $VersionCode = "pub const VERSION: &'static str = `"1.1.9`";"
        Set-Content -Path "src/version.rs" -Value $VersionCode -Encoding UTF8
        
        if (!(Test-Path "src/platform")) { New-Item -ItemType Directory -Path "src/platform" -Force }
        $StubContent = @"
        #include <windows.h>
        #include <stdint.h>
        extern "C" {
            void handleMask(uint8_t* buf, int width, int height, int pitch) {}
            void drawOutline(uint8_t* buf, int width, int height, int pitch, int x, int y, int w, int h) {}
            void get_di_bits(HDC hdc, HBITMAP hbm, int w, int h, uint8_t* buf) {}
            BOOL LaunchProcessWin(const wchar_t* command_line) { return TRUE; }
            BOOL inputDesktopSelected() { return TRUE; }
            BOOL selectInputDesktop() { return TRUE; }
            BOOL get_active_user(wchar_t* buffer, DWORD size) { return TRUE; }
            BOOL blank_screen(BOOL on) { return TRUE; }
            void AddRecentDocument(const wchar_t* path) {}
        }
        "@
        Set-Content -Path "src/platform/windows.cc" -Value $StubContent -Encoding UTF8

    # --- REWRITE BUILD.RS ---
    - name: Rewrite build.rs
      shell: powershell
      run: |
        $AbsPath = (Get-Location).Path.Replace("\", "\\")
        $NewContent = @"
        use std::env;
        use std::fs::File;
        use std::io::Write;
        use std::path::Path;

        fn main() {
            #[cfg(windows)]
            {
                let cc_path = "src/platform/windows.cc";
                if std::path::Path::new(cc_path).exists() {
                    cc::Build::new().file(cc_path).cpp(true).compile("bridge");
                    println!("cargo:rustc-link-lib=static=bridge");
                }
            }
            println!("cargo:rustc-link-search=native=C:\\libs_x86\\lib");
            println!("cargo:rustc-link-lib=static=sodium");

            let out_dir = env::var("OUT_DIR").unwrap();
            let dest_path = Path::new(&out_dir).join("version.rs");
            let mut f = File::create(&dest_path).unwrap();
            f.write_all(b"pub const VERSION: &'static str = \"1.1.9\";").unwrap();

            #[cfg(windows)]
            {
                let mut res = winres::WindowsResource::new();
                res.set_icon("$AbsPath\\icon.ico");
                res.set_manifest_file("$AbsPath\\manifest.xml");
                let _ = res.compile();
            }
        }
        "@
        Set-Content -Path "build.rs" -Value $NewContent -Encoding UTF8

    # --- INSTALAÇÃO VCPKG ---
    - name: Install Dependencies (VCPKG x86)
      shell: powershell
      run: |
        $ErrorActionPreference = "Stop"
        if (Test-Path C:\vcpkg) { Remove-Item C:\vcpkg -Recurse -Force }
        git clone
