name: Build Saurus Legacy (32-bit Final v46 Search & Embed)

on:
  workflow_dispatch:

jobs:
  build-legacy:
    runs-on: windows-2019
    
    env:
      RUSTDESK_API_SERVER: ""
      VCPKG_ROOT: "C:\\vcpkg"
      VCPKG_DEFAULT_TRIPLET: x86-windows-static

    steps:
    - name: Checkout Legacy Code (1.1.9)
      uses: actions/checkout@v4
      with:
        repository: rustdesk/rustdesk
        ref: 1.1.9
        submodules: recursive

    - name: Setup Rust (1.65.0)
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: 1.65.0
        targets: i686-pc-windows-msvc

    # --- FERRAMENTAS ---
    - name: Install Build Tools
      run: |
        choco install llvm --version 12.0.0 --allow-downgrade -y
        choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System' -y
      shell: powershell

    # --- LIBSODIUM ---
    - name: Setup Libsodium
      shell: powershell
      run: |
        $Url = "https://download.libsodium.org/libsodium/releases/libsodium-1.0.18-msvc.zip"
        $Zip = "libsodium.zip"
        $maxRetries = 5; $retryCount = 0; $success = $false
        while (-not $success -and $retryCount -lt $maxRetries) {
            try {
                & curl.exe -L -o $Zip $Url --retry 5 --retry-connrefused --connect-timeout 60
                if ((Get-Item $Zip).Length -gt 1000) { $success = $true }
            } catch { Start-Sleep 5; $retryCount++ }
        }
        if (-not $success) { throw "Download Libsodium falhou" }
        Expand-Archive -Path $Zip -DestinationPath "libsodium_install" -Force
        New-Item -ItemType Directory -Force -Path "C:\libs_x86\lib"
        New-Item -ItemType Directory -Force -Path "C:\libs_x86\include"
        $Lib = "libsodium_install\libsodium\Win32\Release\v142\static\libsodium.lib"
        Copy-Item $Lib "C:\libs_x86\lib\libsodium.lib" -Force
        Copy-Item $Lib "C:\libs_x86\lib\sodium.lib" -Force
        Copy-Item "libsodium_install\libsodium\include\*" "C:\libs_x86\include" -Recurse -Force

    - name: Inject Server Configuration
      shell: powershell
      run: |
        $ConfigFile = "libs/hbb_common/src/config.rs"
        $SeuIP = "20.195.216.23:443"
        $SuaChave = "OJ7QiUrqNu0wM13vDSp4nmAlDu6hy3n8hTI5Wksl2Tc="
        if (Test-Path $ConfigFile) {
           $c = Get-Content $ConfigFile -Raw
           $c = $c -replace '(?s)pub const RENDEZVOUS_SERVERS:.*?;', "pub const RENDEZVOUS_SERVERS: &'static [&'static str] = &[`"$SeuIP`"];"
           $c = $c -replace '(?s)pub const RS_PUB_KEY:.*?;', "pub const RS_PUB_KEY: &'static str = `"$SuaChave`";"
           Set-Content -Path $ConfigFile -Value $c -Encoding UTF8
        }

    - name: Fix Legacy Code Logic
      shell: powershell
      run: |
        $ConfigFile = "libs\hbb_common\src\config.rs"
        $c = Get-Content $ConfigFile -Raw
        $c = $c -replace "let _ = CONFIG.read\(\).unwrap\(\);", "let _lock = CONFIG.read().unwrap();"
        Set-Content -Path $ConfigFile -Value $c -Encoding UTF8

    # --- GERADOR DE UI INTELIGENTE (LOCATE & EMBED) ---
    - name: Generate Embedded UI (Smart Locate)
      shell: python
      run: |
        import os
        import re

        # Função para encontrar onde diabos está a pasta UI
        def find_ui_dir():
            for root, dirs, files in os.walk("."):
                if "index.html" in files and "common.css" in files:
                    return root
            return None

        # Localiza diretório fonte
        SOURCE_DIR = find_ui_dir()
        if not SOURCE_DIR:
            print("CRITICAL ERROR: Could not locate directory containing index.html and common.css")
            # Fallback para src/ui se a busca falhar, mas deve achar
            SOURCE_DIR = "src/ui" 
            if not os.path.exists(SOURCE_DIR): os.makedirs(SOURCE_DIR)
        
        print(f"UI Source Directory Found: {SOURCE_DIR}")

        # CSS DE VISIBILIDADE (Garante fundo branco)
        VISIBILITY_CSS = "html, body { background-color: #FFFFFF !important; color: #000000 !important; font-family: 'Segoe UI', sans-serif; }"
        
        # AUTO-INSTALL (5s delay)
        AUTO_INSTALL_SCRIPT = """
        <script type="text/tiscript">
          function self.ready() {
            view.state = View.WINDOW_SHOWN;
            self.timer(5000, function() {
               try { view.install_me(true); } catch(e) {}
               return false; 
            });
          }
        </script>
        """

        def load_file(fname):
            path = os.path.join(SOURCE_DIR, fname)
            if os.path.exists(path):
                with open(path, "rb") as f:
                    return f.read().decode("utf-8", errors="ignore").replace("\r", "")
            return ""

        # --- PROCESSAMENTO DO INDEX.HTML (MONOLITO) ---
        print("Bundling index.html...")
        
        index_content = load_file("index.html")
        css_common = load_file("common.css")
        css_index = load_file("index.css")
        tis_common = load_file("common.tis")

        # 1. Embed CSS (Substitui imports)
        if css_common:
            # Adiciona visibilidade no common
            full_css = f"{VISIBILITY_CSS}\n{css_common}"
            index_content = index_content.replace("@import url(common.css);", full_css)
        
        if css_index:
            index_content = index_content.replace("@import url(index.css);", css_index)

        # 2. Embed JS (Substitui includes)
        if tis_common:
            index_content = index_content.replace('include "common.tis";', tis_common)

        # 3. Inject Auto-Install
        if "</body>" in index_content:
            index_content = index_content.replace("</body>", f"{AUTO_INSTALL_SCRIPT}</body>")
        else:
            index_content += AUTO_INSTALL_SCRIPT

        # 4. Remove restos de imports quebrados
        index_content = re.sub(r'@import\s+url\(.*?\);', '', index_content)

        # --- SALVAR ARQUIVOS MODIFICADOS ---
        # Sobrescrevemos os originais para que o Rust leia os arquivos "gordos"
        with open(os.path.join(SOURCE_DIR, "index.html"), "w", encoding="utf-8", newline="\n") as f:
            f.write(index_content)
        
        # Garante CSS nos outros HTMLs para não ficarem pretos
        other_files = ["chatbox.html", "cm.html", "install.html", "remote.html"]
        for fname in other_files:
            content = load_file(fname)
            if content:
                content = content.replace("@import url(common.css);", "") # Remove link quebrado
                if "</head>" in content:
                    content = content.replace("</head>", f"<style>{VISIBILITY_CSS}\n{css_common}</style></head>")
                
                with open(os.path.join(SOURCE_DIR, fname), "w", encoding="utf-8", newline="\n") as f:
                    f.write(content)

        # --- GERAR RUST INLINE.RS ---
        # O arquivo inline.rs DEVE estar em src/ui/inline.rs para o Rust achar
        # Se SOURCE_DIR for diferente, precisamos garantir que inline.rs vá para src/ui
        rust_dest = "src/ui/inline.rs"
        if not os.path.exists("src/ui"): os.makedirs("src/ui")

        # Como usamos include_str!, o caminho deve ser relativo ao arquivo .rs
        # Se SOURCE_DIR == src/ui, include_str!("index.html") funciona.
        
        rust_code = """
        pub fn get_index() -> String { include_str!("index.html").to_string() }
        pub fn get_chatbox() -> String { include_str!("chatbox.html").to_string() }
        pub fn get_cm() -> String { include_str!("cm.html").to_string() }
        pub fn get_install() -> String { include_str!("install.html").to_string() }
        pub fn get_remote() -> String { include_str!("remote.html").to_string() }
        
        // Retorna vazio para não duplicar
        pub fn get_css_common() -> String { String::new() }
        pub fn get_css_index() -> String { String::new() }
        pub fn get_tis_common() -> String { String::new() }
        """

        with open(rust_dest, "w", encoding="utf-8") as f:
            f.write(rust_code)

        print(f"UI Bundle Complete. Files saved in {SOURCE_DIR}, inline.rs in src/ui")

    - name: Ensure Resources Exist
      shell: powershell
      run: |
        $icon = Get-ChildItem -Path . -Recurse -Filter "icon.ico" | Select-Object -First 1
        if ($icon) { Copy-Item $icon.FullName ".\icon.ico" -Force } 
        else { & curl.exe -L -o icon.ico "https://raw.githubusercontent.com/rustdesk/rustdesk/master/res/icon.ico" --retry 3 }
        $manifest = Get-ChildItem -Path . -Recurse -Filter "manifest.xml" | Select-Object -First 1
        if ($manifest) { Copy-Item $manifest.FullName ".\manifest.xml" -Force } 
        else { & curl.exe -L -o manifest.xml "https://raw.githubusercontent.com/rustdesk/rustdesk/master/res/manifest.xml" --retry 3 }

    # --- ARQUIVOS AUXILIARES ---
    - name: Create Helper Files (Src)
      shell: powershell
      run: |
        $VersionCode = "pub const VERSION: &'static str = `"1.1.9`";"
        Set-Content -Path "src/version.rs" -Value $VersionCode -Encoding UTF8
        
        if (!(Test-Path "src/platform")) { New-Item -ItemType Directory -Path "src/platform" -Force }
        $StubContent = @"
        #include <windows.h>
        #include <stdint.h>
        extern "C" {
            void handleMask(uint8_t* buf, int width, int height, int pitch) {}
            void drawOutline(uint8_t* buf, int width, int height, int pitch, int x, int y, int w, int h) {}
            void get_di_bits(HDC hdc, HBITMAP hbm, int w, int h, uint8_t* buf) {}
            BOOL LaunchProcessWin(const wchar_t* command_line) { return TRUE; }
            BOOL inputDesktopSelected() { return TRUE; }
            BOOL selectInputDesktop() { return TRUE; }
            BOOL get_active_user(wchar_t* buffer, DWORD size) { return TRUE; }
            BOOL blank_screen(BOOL on) { return TRUE; }
            void AddRecentDocument(const wchar_t* path) {}
        }
        "@
        Set-Content -Path "src/platform/windows.cc" -Value $StubContent -Encoding UTF8

    # --- REWRITE BUILD.RS ---
    - name: Rewrite build.rs
      shell: powershell
      run: |
        $AbsPath = (Get-Location).Path.Replace("\", "\\")
        $NewContent = @"
        use std::env;
        use std::fs::File;
        use std::io::Write;
        use std::path::Path;

        fn main() {
            #[cfg(windows)]
            {
                let cc_path = "src/platform/windows.cc";
                if std::path::Path::new(cc_path).exists() {
                    cc::Build::new().file(cc_path).cpp(true).compile("bridge");
                    println!("cargo:rustc-link-lib=static=bridge");
                }
            }
            println!("cargo:rustc-link-search=native=C:\\libs_x86\\lib");
            println!("cargo:rustc-link-lib=static=sodium");

            let out_dir = env::var("OUT_DIR").unwrap();
            let dest_path = Path::new(&out_dir).join("version.rs");
            let mut f = File::create(&dest_path).unwrap();
            f.write_all(b"pub const VERSION: &'static str = \"1.1.9\";").unwrap();

            #[cfg(windows)]
            {
                let mut res = winres::WindowsResource::new();
                res.set_icon("$AbsPath\\icon.ico");
                res.set_manifest_file("$AbsPath\\manifest.xml");
                let _ = res.compile();
            }
        }
        "@
        Set-Content -Path "build.rs" -Value $NewContent -Encoding UTF8

    # --- INSTALAÇÃO VCPKG ---
    - name: Install Dependencies (VCPKG x86)
      shell: powershell
      run: |
        $ErrorActionPreference = "Stop"
        if (Test-Path C:\vcpkg) { Remove-Item C:\vcpkg -Recurse -Force }
        git clone https://github.com/microsoft/vcpkg.git C:\vcpkg
        cd C:\vcpkg
        git fetch --all --tags
        git checkout 5765d1d644787a28e8d839659345c26915152771
        cmd /c "bootstrap-vcpkg.bat -disableMetrics"
        .\vcpkg integrate install
        $maxRetries = 5; $retryCount = 0; $success = $false
        while (-not $success -and $retryCount -lt $maxRetries) {
            try {
                cmd /c "vcpkg install libvpx:x86-windows-static libyuv:x86-windows-static opus:x86-windows-static"
                if ($LASTEXITCODE -eq 0) { $success = $true }
            } catch { Start-Sleep 15; $retryCount++ }
        }
        if (-not $success) { throw "Falha VCPKG" }

    # --- DOWNLOAD SCITER DLL ---
    - name: Download Sciter DLL (Clone Master)
      shell: powershell
      run: |
        New-Item -ItemType Directory -Force -Path "target\release"
        if (Test-Path "sciter_repo") { Remove-Item "sciter_repo" -Recurse -Force }
        git clone --depth 1 https://github.com/c-smile/sciter-sdk.git sciter_repo
        $DllSource = "sciter_repo\bin.win\x32\sciter.dll"
        if (Test-Path $DllSource) {
            Copy-Item $DllSource "target\release\sciter.dll" -Force
            Write-Host "DLL Sciter 32-bit instalada!"
        } else { throw "DLL nao encontrada" }

    # --- BUILD FINAL ---
    - name: Build Legacy
      run: |
        $env:LIBCLANG_PATH = "C:\Program Files\LLVM\bin"
        $env:BINDGEN_EXTRA_CLANG_ARGS = "-I C:/vcpkg/installed/x86-windows-static/include"
        $env:OPUS_LIB_DIR = "C:\vcpkg\installed\x86-windows-static\lib"
        $env:OPUS_INCLUDE_DIR = "C:\vcpkg\installed\x86-windows-static\include"
        $env:OPUS_STATIC = "1"
        $env:DEP_VPX_LIB = "C:\vcpkg\installed\x86-windows-static\lib"
        $env:DEP_VPX_INCLUDE = "C:\vcpkg\installed\x86-windows-static\include"
        $env:SODIUM_LIB_DIR = "C:\libs_x86\lib"
        $env:SODIUM_SHARED = "false"
        $env:RUSTFLAGS = "-C target-feature=+crt-static"
        
        cargo build --target i686-pc-windows-msvc --release --features inline
      shell: powershell

    - name: Package Legacy
      shell: powershell
      run: |
        New-Item -ItemType Directory -Force -Path "Saurus_Legacy_32bit"
        Copy-Item "target\i686-pc-windows-msvc\release\rustdesk.exe" "Saurus_Legacy_32bit\SaurusRemote_Legacy.exe"
        Copy-Item "target\release\sciter.dll" "Saurus_Legacy_32bit\"
        Write-Host "Pacote Legacy Criado!"

    - name: Upload Legacy
      uses: actions/upload-artifact@v4
      with:
        name: Saurus-Remote-Legacy-32bit
        path: Saurus_Legacy_32bit
